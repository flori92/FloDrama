/**
 * Scraper optimis√© pour FloDrama
 * 
 * Ce script utilise une approche plus cibl√©e et des techniques avanc√©es
 * pour contourner les protections anti-scraping les plus strictes
 * avec playwright et des techniques de furtivit√©
 */

const fs = require('fs-extra');
const path = require('path');
const { chromium } = require('playwright');
const cheerio = require('cheerio');
const { randomDelay, getRandomUserAgent } = require('./utils');
const { extractData } = require('./extractors');

// Configuration
const CONFIG = {
  OUTPUT_DIR: './Frontend/src/data/content',
  CATEGORIES: ['drama', 'anime', 'film', 'bollywood'],
  STEALTH_MODE: true,
  BROWSER_ARGS: [
    '--disable-blink-features=AutomationControlled',
    '--disable-dev-shm-usage',
    '--disable-setuid-sandbox',
    '--no-sandbox',
    '--disable-web-security'
  ],
  // Sources prioritaires avec des URLs alternatives et pagination
  SOURCES: [
    // Dramas
    {
      name: 'dramacool',
      urls: [
        'https://dramacool.com.pa/most-popular-drama',
        'https://dramacool.sr/most-popular-drama',
        'https://dramacool.bid/most-popular-drama',
        'https://dramacool.com.pa/drama-list',
        'https://dramacool.sr/drama-list',
        'https://dramacool.bid/drama-list',
        'https://dramacool.com.pa/recently-added',
        'https://dramacool.sr/recently-added',
        'https://dramacool.bid/recently-added'
      ],
      paginationPattern: 'page/{page}/',  // Format de pagination
      paginationMax: 5,                  // Nombre maximum de pages √† scraper
      type: 'drama',
      selector: '.block',
      waitForSelector: '.block',
      minItems: 200,
      retryCount: 3                      // Nombre de tentatives en cas d'√©chec
    },
    {
      name: 'mydramalist',
      urls: [
        'https://mydramalist.com/shows/top',
        'https://mydramalist.com/shows/top_korean_dramas',
        'https://mydramalist.com/shows/top_chinese_dramas',
        'https://mydramalist.com/shows/top_japanese_dramas',
        'https://mydramalist.com/shows/top_taiwanese_dramas',
        'https://mydramalist.com/shows/popular',
        'https://mydramalist.com/shows/ongoing'
      ],
      paginationPattern: '?page={page}',  // Format de pagination
      paginationMax: 5,                  // Nombre maximum de pages √† scraper
      type: 'drama',
      selector: '.box-body.light-b',
      waitForSelector: '.box-body',
      minItems: 200,
      retryCount: 3
    },
    // Animes
    {
      name: 'myanimelist',
      urls: [
        'https://myanimelist.net/topanime.php',
        'https://myanimelist.net/topanime.php?type=airing',
        'https://myanimelist.net/topanime.php?type=upcoming',
        'https://myanimelist.net/topanime.php?type=tv',
        'https://myanimelist.net/topanime.php?type=movie',
        'https://myanimelist.net/topanime.php?type=ova',
        'https://myanimelist.net/topanime.php?type=special'
      ],
      paginationPattern: '?limit=50&offset={offset}',  // Format de pagination bas√© sur offset
      paginationOffsetMultiplier: 50,                // Valeur d'incr√©mentation de l'offset
      paginationMax: 4,                              // Nombre maximum de pages √† scraper
      type: 'anime',
      selector: '.ranking-list',
      waitForSelector: '.ranking-list',
      minItems: 200,
      retryCount: 3
    },
    // Films
    {
      name: 'imdb',
      urls: [
        'https://www.imdb.com/chart/top/',
        'https://www.imdb.com/chart/moviemeter/',
        'https://www.imdb.com/chart/boxoffice',
        'https://www.imdb.com/movies-coming-soon/',
        'https://www.imdb.com/movies-in-theaters/'
      ],
      type: 'film',
      selector: '.ipc-metadata-list-summary-item',
      waitForSelector: '.ipc-metadata-list-summary-item',
      minItems: 200,
      retryCount: 3
    },
    // Bollywood
    {
      name: 'bollywood',
      urls: [
        'https://www.bollywoodhungama.com/movies/',
        'https://www.bollywoodlife.com/bollywood-movies/',
        'https://www.bollywoodhungama.com/movies/top-100-movies/',
        'https://www.bollywoodhungama.com/movies/bollywood-movies/',
        'https://www.bollywoodlife.com/box-office/'
      ],
      paginationPattern: 'page/{page}/',  // Format de pagination
      paginationMax: 5,                  // Nombre maximum de pages √† scraper
      type: 'bollywood',
      selector: '.movie-box, .article-box',
      waitForSelector: '.movie-box, .article-box',
      minItems: 200,
      retryCount: 3
    }
  ]
};

// Statistiques
const stats = {
  total_items: 0,
  sources_processed: 0,
  sources_failed: 0,
  categories: {},
  start_time: new Date()
};

/**
 * Fonction principale
 */
async function main() {
  console.log('='.repeat(80));
  console.log(`FloDrama - Scraper Optimis√©`);
  console.log('='.repeat(80));
  
  // Cr√©er les r√©pertoires n√©cessaires
  await fs.ensureDir(CONFIG.OUTPUT_DIR);
  for (const category of CONFIG.CATEGORIES) {
    await fs.ensureDir(path.join(CONFIG.OUTPUT_DIR, category));
  }
  
  console.log(`\nüîç D√©marrage du scraping pour ${CONFIG.SOURCES.length} sources prioritaires...`);
  
  // Lancer un navigateur unique pour toutes les sources avec stealth
  const browser = await chromium.launch({
    headless: false, // Mode visible pour √©viter la d√©tection
    args: [
      ...CONFIG.BROWSER_ARGS,
      '--disable-features=IsolateOrigins,site-per-process',
      '--disable-site-isolation-trials',
      '--disable-web-security',
      '--disable-features=site-per-process',
      '--disable-extensions'
    ]
  });
  
  try {
    // Traiter chaque source s√©quentiellement
    for (const source of CONFIG.SOURCES) {
      await scrapeSource(browser, source);
    }
    
    // G√©n√©rer les fichiers par cat√©gorie
    await generateCategoryFiles();
    
  } finally {
    // Fermer le navigateur
    await browser.close();
  }
  
  // Calculer la dur√©e totale
  stats.end_time = new Date();
  stats.duration_ms = stats.end_time - stats.start_time;
  stats.duration_formatted = formatDuration(stats.duration_ms);
  
  // Afficher les statistiques
  console.log('\nüìä Statistiques du scraping:');
  console.log(`‚è±Ô∏è Dur√©e totale: ${stats.duration_formatted}`);
  console.log(`üì¶ Total d'√©l√©ments: ${stats.total_items}`);
  console.log(`‚úÖ Sources trait√©es: ${stats.sources_processed}/${CONFIG.SOURCES.length}`);
  console.log(`‚ùå Sources en √©chec: ${stats.sources_failed}`);
  
  // Afficher les statistiques par cat√©gorie
  console.log('\nüìÇ Statistiques par cat√©gorie:');
  for (const [category, count] of Object.entries(stats.categories)) {
    console.log(`- ${category}: ${count} √©l√©ments`);
  }
  
  console.log('\n‚ú® Scraping termin√© avec succ√®s!');
}

/**
 * Scrape une source sp√©cifique
 * @param {Browser} browser - Instance du navigateur
 * @param {Object} source - Configuration de la source
 * @returns {Promise<boolean>} - Succ√®s ou √©chec
 */
async function scrapeSource(browser, source) {
  console.log(`\nüîç Scraping de ${source.name}...`);
  
  const allItems = [];
  let success = false;
  
  try {
    // Cr√©er un contexte avec des param√®tres furtifs
    const context = await browser.newContext({
      userAgent: getRandomUserAgent(),
      viewport: { width: 1920, height: 1080 },
      deviceScaleFactor: 1,
      hasTouch: false,
      isMobile: false,
      javaScriptEnabled: true,
      locale: 'fr-FR',
      timezoneId: 'Europe/Paris',
      geolocation: { longitude: 2.3488, latitude: 48.8534 },
      permissions: ['geolocation'],
      colorScheme: 'light',
      ignoreHTTPSErrors: true,
      extraHTTPHeaders: {
        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8',
        'Accept-Language': 'fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7',
        'Cache-Control': 'max-age=0',
        'Sec-Fetch-Dest': 'document',
        'Sec-Fetch-Mode': 'navigate',
        'Sec-Fetch-Site': 'none',
        'Sec-Fetch-User': '?1',
        'Upgrade-Insecure-Requests': '1',
        'Referer': 'https://www.google.com/'
      }
    });
    
    // Le plugin stealth s'occupe d√©j√† de masquer l'automatisation
    // Mais on ajoute quelques scripts suppl√©mentaires pour renforcer la furtivit√©
    await context.addInitScript(() => {
      // Simuler des mouvements de souris al√©atoires
      const originalQuerySelector = document.querySelector;
      document.querySelector = function(...args) {
        // Simuler un d√©lai al√©atoire
        const delay = Math.floor(Math.random() * 20);
        if (delay > 0) {
          for (let i = 0; i < delay * 1000000; i++) {
            // Boucle vide pour cr√©er un d√©lai
          }
        }
        return originalQuerySelector.apply(document, args);
      };
      
      // Simuler un historique de navigation
      history.length = Math.floor(Math.random() * 5) + 2;
      
      // Simuler une batterie
      if (!navigator.getBattery) {
        navigator.getBattery = () => Promise.resolve({
          charging: Math.random() > 0.5,
          chargingTime: Math.floor(Math.random() * 3000),
          dischargingTime: Math.floor(Math.random() * 10000),
          level: Math.random()
        });
      }
    });
    
    // Cr√©er une page
    const page = await context.newPage();
    
    // Parcourir toutes les URLs de la source
    for (const url of source.urls) {
          }
          // Sinon, on ajoute simplement le pattern √† l'URL de base
          else {
            // V√©rifier si l'URL de base se termine par / et si le pattern commence par /
            if (baseUrl.endsWith('/') && source.paginationPattern.startsWith('/')) {
              paginatedUrl = `${baseUrl}${source.paginationPattern.substring(1).replace('{page}', i)}`;
            } else if (!baseUrl.endsWith('/') && !source.paginationPattern.startsWith('/')) {
              paginatedUrl = `${baseUrl}/${source.paginationPattern.replace('{page}', i)}`;
            } else {
              paginatedUrl = `${baseUrl}${source.paginationPattern.replace('{page}', i)}`;
            }
          }
          urls.push(paginatedUrl);
        }
      }
    }
    
    return urls;
  };
  
  // Fonction pour d√©dupliquer les √©l√©ments avec une meilleure strat√©gie
  const deduplicateItems = (items) => {
    const uniqueItems = [];
    const seenIds = new Set();
    const seenTitles = new Set();
    const seenUrls = new Set();
    
    for (const item of items) {
      // G√©n√©rer un identifiant unique bas√© sur le titre et l'ann√©e si l'ID n'existe pas
      if (!item.id && item.title) {
        item.id = `${item.title.toLowerCase().replace(/[^a-z0-9]/g, '')}_${item.year || 'unknown'}`;
      }
      
      // V√©rifier si l'ID, le titre ou l'URL a d√©j√† √©t√© vu
      const titleKey = item.title ? item.title.toLowerCase().trim() : null;
      const urlKey = item.url || item.link || null;
      
      if (
        (item.id && !seenIds.has(item.id)) &&
        (titleKey === null || !seenTitles.has(titleKey)) &&
        (urlKey === null || !seenUrls.has(urlKey))
      ) {
        if (item.id) seenIds.add(item.id);
        if (titleKey) seenTitles.add(titleKey);
        if (urlKey) seenUrls.add(urlKey);
        uniqueItems.push(item);
      }
    }
    
    return uniqueItems;
  };
  
  // Boucle de retry
  while (retryCount < maxRetries && !success) {
    try {
      // Cr√©er un nouveau contexte pour chaque tentative
      const context = await browser.newContext({
        userAgent: getRandomUserAgent(),
        viewport: {
          width: 1920 + Math.floor(Math.random() * 100),
          height: 1080 + Math.floor(Math.random() * 100)
        },
        deviceScaleFactor: 1,
        hasTouch: false,
        javaScriptEnabled: true,
        locale: 'fr-FR',
        timezoneId: 'Europe/Paris',
        geolocation: { longitude: 2.3488, latitude: 48.8534 },
        permissions: ['geolocation']
      });
      
      // Intercepter les requ√™tes pour d√©tecter les protections anti-bot
      await context.route('**/*', async (route) => {
        const request = route.request();
        const url = request.url();
        
        // V√©rifier les patterns de d√©tection de bots
        if (url.includes('captcha') || 
            url.includes('cloudflare') || 
            url.includes('challenge') || 
            url.includes('cf_chl_')) {
          console.warn(`[${source.name}] D√©tection de protection anti-bot: ${url}`);
        }
        
        await route.continue();
      });
      
      // Ajouter des scripts de furtivit√©
      await context.addInitScript(() => {
        // Masquer les indicateurs d'automatisation
        Object.defineProperty(navigator, 'webdriver', { get: () => false });
        
        // Simuler des fonctions de navigateur standard
        if (!window.chrome) {
          window.chrome = {};
        }
        
        // Fonction pour simuler la batterie
        const getBattery = function() {
          return Promise.resolve({
            charging: Math.random() > 0.5,
            chargingTime: Math.floor(Math.random() * 1000),
            dischargingTime: Math.floor(Math.random() * 1000),
            level: Math.random()
          });
        };
        
        // Ajouter la fonction getBattery √† navigator
        if (!navigator.getBattery) {
          navigator.getBattery = getBattery;
        }
      });
      
      // Cr√©er une page
      const page = await context.newPage();
      
      // Parcourir toutes les URLs de la source avec pagination
      for (const baseUrl of source.urls) {
        // G√©n√©rer les URLs pagin√©es
        const paginatedUrls = generatePaginatedUrls(baseUrl);
        console.log(`[${source.name}] ${paginatedUrls.length} URLs g√©n√©r√©es pour ${baseUrl}`);
        
        // Parcourir chaque URL pagin√©e
        for (const url of paginatedUrls) {
          try {
            console.log(`[${source.name}] Acc√®s √† ${url}`);
            
            // Acc√©der √† l'URL
            await page.goto(url, { 
              waitUntil: 'networkidle',
              timeout: 60000 
            });
            
            // Attendre un d√©lai al√©atoire pour simuler un comportement humain
            await randomDelay(2000, 5000);
            
            // Faire d√©filer lentement la page pour simuler un comportement humain
            await autoScrollSlow(page);
            
            // Attendre un s√©lecteur sp√©cifique si n√©cessaire
            if (source.waitForSelector) {
              await page.waitForSelector(source.waitForSelector, { timeout: 15000 })
                .catch(() => console.log(`[${source.name}] S√©lecteur ${source.waitForSelector} non trouv√©, on continue`));
            }
            
            // R√©cup√©rer le HTML
            const html = await page.content();
            
            // Extraire les donn√©es
            const items = extractData(source.name, html, { url, selector: source.selector });
            
            console.log(`[${source.name}] ${items.length} √©l√©ments r√©cup√©r√©s depuis ${url}`);
            
            if (items.length > 0) {
              allItems.push(...items);
              success = true;
              
              // Prendre une capture d'√©cran pour d√©bogage si n√©cessaire
              if (process.env.DEBUG === 'true') {
                const screenshotPath = path.join('./cloudflare/scraping/screenshots', `${source.name}_${Date.now()}.png`);
                await fs.ensureDir(path.dirname(screenshotPath));
                await page.screenshot({ path: screenshotPath, fullPage: true });
                console.log(`[${source.name}] Capture d'√©cran sauvegard√©e: ${screenshotPath}`);
              }
            }
            
            // V√©rifier si nous avons atteint le nombre minimum d'√©l√©ments
            const uniqueCount = deduplicateItems(allItems).length;
            if (uniqueCount >= source.minItems) {
              console.log(`[${source.name}] Nombre minimum d'√©l√©ments atteint (${uniqueCount}/${source.minItems}), arr√™t du scraping`);
              break;
            }
            
            // Attendre entre chaque URL avec un d√©lai variable
            await randomDelay(5000, 12000);
          } catch (error) {
            console.error(`[${source.name}] Erreur lors du scraping de ${url}: ${error.message}`);
          }
        }
        
        // V√©rifier si nous avons atteint le nombre minimum d'√©l√©ments apr√®s avoir trait√© toutes les URLs pagin√©es
        const uniqueCount = deduplicateItems(allItems).length;
        if (uniqueCount >= source.minItems) {
          console.log(`[${source.name}] Nombre minimum d'√©l√©ments atteint (${uniqueCount}/${source.minItems}), passage √† la source suivante`);
          break;
        }
      }
      
      // Fermer le contexte
      await context.close();
      
      // Si nous avons des √©l√©ments, pas besoin de r√©essayer
      if (allItems.length > 0) {
        break;
      }
      
    } catch (error) {
      console.error(`[${source.name}] Erreur globale (tentative ${retryCount + 1}/${maxRetries}): ${error.message}`);
      retryCount++;
      
      // Attendre plus longtemps entre les tentatives
      await randomDelay(10000, 20000);
    }
  }
  
  // D√©dupliquer les √©l√©ments avec la strat√©gie am√©lior√©e
  const uniqueItems = deduplicateItems(allItems);
  
  console.log(`[${source.name}] ${uniqueItems.length}/${allItems.length} √©l√©ments uniques apr√®s d√©duplication`);
  
  // Sauvegarder les donn√©es
  if (uniqueItems.length > 0) {
    await saveData(source.name, uniqueItems);
    
    // Mettre √† jour les statistiques
    stats.total_items += uniqueItems.length;
    stats.sources_processed++;
    
    // Mettre √† jour les statistiques par cat√©gorie
    const category = source.type || 'unknown';
    stats.categories[category] = (stats.categories[category] || 0) + uniqueItems.length;
    
    // V√©rifier si nous avons atteint l'objectif
    const success = uniqueItems.length >= source.minItems;
    if (!success) {
      console.warn(`[${source.name}] Objectif non atteint: ${uniqueItems.length}/${source.minItems} √©l√©ments uniques`);
    }
    
    return success;
  } else {
    console.error(`[${source.name}] √âchec apr√®s ${maxRetries} tentatives: aucun √©l√©ment r√©cup√©r√©`);
    stats.sources_failed++;
    return false;
  }
}
/**
 * Fait d√©filer automatiquement une page lentement pour simuler un comportement humain
 * @param {Page} page - Instance de la page Playwright
 */
async function autoScrollSlow(page) {
  await page.evaluate(async () => {
    await new Promise((resolve) => {
      let totalHeight = 0;
      const distance = 50; // Scroll plus petit
      const timer = setInterval(() => {
        // Ajouter des variations al√©atoires dans le d√©filement
        const scrollDistance = distance + Math.floor(Math.random() * 30) - 15;
        const { scrollHeight } = document.body;
        window.scrollBy(0, scrollDistance);
        totalHeight += scrollDistance;
        
        // Parfois, faire une pause plus longue pour simuler la lecture
        if (Math.random() < 0.1) {
          clearInterval(timer);
          setTimeout(() => {
            // Reprendre le d√©filement apr√®s une pause
            if (totalHeight < scrollHeight) {
              const resumeTimer = setInterval(() => {
                const resumeDistance = distance + Math.floor(Math.random() * 30) - 15;
                window.scrollBy(0, resumeDistance);
                totalHeight += resumeDistance;
                
                if (totalHeight >= scrollHeight) {
                  clearInterval(resumeTimer);
                  resolve();
                }
              }, 200 + Math.floor(Math.random() * 100));
            } else {
              resolve();
            }
          }, 1000 + Math.floor(Math.random() * 2000));
        }
        
        if (totalHeight >= scrollHeight) {
          clearInterval(timer);
          resolve();
        }
      }, 200 + Math.floor(Math.random() * 100)); // Vitesse variable
    });
  });
}

/**
 * Sauvegarde les donn√©es dans un fichier JSON
 * @param {string} sourceName - Nom de la source
 * @param {Array} items - √âl√©ments √† sauvegarder
 */
async function saveData(sourceName, items) {
  try {
    const outputFile = path.join(CONFIG.OUTPUT_DIR, `${sourceName}.json`);
    await fs.writeJson(outputFile, items, { spaces: 2 });
    console.log(`[${sourceName}] Donn√©es sauvegard√©es dans ${outputFile}`);
    return true;
  } catch (error) {
    console.error(`[${sourceName}] Erreur lors de la sauvegarde des donn√©es: ${error.message}`);
    return false;
  }
}

/**
 * G√©n√®re des fichiers par cat√©gorie
 */
async function generateCategoryFiles() {
  console.log('\nüìÇ G√©n√©ration des fichiers par cat√©gorie...');
  
  // R√©cup√©rer tous les fichiers JSON sources
  const sourceFiles = await fs.readdir(CONFIG.OUTPUT_DIR);
  const jsonFiles = sourceFiles.filter(file => 
    file.endsWith('.json') && 
    !file.includes('index') && 
    !file.startsWith('.')
  );
  
  // Collecter tous les √©l√©ments par cat√©gorie
  const categorizedItems = {};
  CONFIG.CATEGORIES.forEach(category => {
    categorizedItems[category] = [];
  });
  
  // Parcourir tous les fichiers sources
  for (const file of jsonFiles) {
    try {
      const filePath = path.join(CONFIG.OUTPUT_DIR, file);
      const data = await fs.readJson(filePath);
      
      // V√©rifier si les donn√©es sont un tableau ou un objet avec une propri√©t√© results
      const items = Array.isArray(data) ? data : (data.results || []);
      
      if (items.length === 0) {
        console.warn(`‚ö†Ô∏è Aucun √©l√©ment trouv√© dans ${file}`);
        continue;
      }
      
      // Cat√©goriser les √©l√©ments
      items.forEach(item => {
        // D√©terminer la cat√©gorie de l'√©l√©ment
        let category = item.type || 'unknown';
        
        // Mapper les types sp√©cifiques aux cat√©gories g√©n√©rales
        if (['kdrama', 'cdrama', 'jdrama', 'drama', 'series'].includes(category)) {
          category = 'drama';
        } else if (['anime', 'animation'].includes(category)) {
          category = 'anime';
        } else if (['film', 'movie', 'movies'].includes(category)) {
          category = 'film';
        } else if (['bollywood', 'indian'].includes(category)) {
          category = 'bollywood';
        }
        
        // Ajouter l'√©l√©ment √† sa cat√©gorie si elle est support√©e
        if (CONFIG.CATEGORIES.includes(category)) {
          categorizedItems[category].push(item);
        }
      });
    } catch (error) {
      console.error(`‚ùå Erreur lors du traitement de ${file}: ${error.message}`);
    }
  }
  
  // G√©n√©rer les fichiers par cat√©gorie
  for (const category of CONFIG.CATEGORIES) {
    const items = categorizedItems[category];
    
    if (items.length === 0) {
      console.warn(`‚ö†Ô∏è Aucun √©l√©ment pour la cat√©gorie ${category}`);
      continue;
    }
    
    console.log(`üì¶ G√©n√©ration des fichiers pour ${category}: ${items.length} √©l√©ments`);
    
    // Trier les √©l√©ments par ann√©e (d√©croissant) puis par note (d√©croissant)
    items.sort((a, b) => {
      if (b.year !== a.year) {
        return b.year - a.year;
      }
      return b.rating - a.rating;
    });
    
    // G√©n√©rer le fichier index.json
    const categoryDir = path.join(CONFIG.OUTPUT_DIR, category);
    await fs.ensureDir(categoryDir);
    
    const indexFile = path.join(categoryDir, 'index.json');
    await fs.writeJson(indexFile, {
      count: items.length,
      results: items,
      updated_at: new Date().toISOString()
    }, { spaces: 2 });
    
    console.log(`‚úÖ Fichier index g√©n√©r√©: ${indexFile} (${items.length} √©l√©ments)`);
    
    // G√©n√©rer le fichier trending.json
    const trendingItems = [...items]
      .sort((a, b) => {
        const currentYear = new Date().getFullYear();
        const aIsRecent = a.year >= currentYear - 2;
        const bIsRecent = b.year >= currentYear - 2;
        
        if (aIsRecent !== bIsRecent) {
          return aIsRecent ? -1 : 1;
        }
        return b.rating - a.rating;
      })
      .slice(0, 20);
    
    const trendingFile = path.join(categoryDir, 'trending.json');
    await fs.writeJson(trendingFile, {
      count: trendingItems.length,
      results: trendingItems,
      updated_at: new Date().toISOString()
    }, { spaces: 2 });
    
    console.log(`‚úÖ Fichier trending g√©n√©r√©: ${trendingFile} (${trendingItems.length} √©l√©ments)`);
    
    // G√©n√©rer le fichier hero_banner.json
    const heroBannerItems = [...items]
      .filter(item => item.backdrop && item.poster)
      .sort((a, b) => {
        const currentYear = new Date().getFullYear();
        const aIsVeryRecent = a.year >= currentYear;
        const bIsVeryRecent = b.year >= currentYear;
        
        if (aIsVeryRecent !== bIsVeryRecent) {
          return aIsVeryRecent ? -1 : 1;
        }
        return b.rating - a.rating;
      })
      .slice(0, 5);
    
    const heroBannerFile = path.join(categoryDir, 'hero_banner.json');
    await fs.writeJson(heroBannerFile, {
      count: heroBannerItems.length,
      results: heroBannerItems,
      updated_at: new Date().toISOString()
    }, { spaces: 2 });
    
    console.log(`‚úÖ Fichier hero_banner g√©n√©r√©: ${heroBannerFile} (${heroBannerItems.length} √©l√©ments)`);
  }
  
  // G√©n√©rer un fichier global pour toutes les cat√©gories
  const globalFile = path.join(CONFIG.OUTPUT_DIR, 'global.json');
  await fs.writeJson(globalFile, {
    total_items: Object.values(categorizedItems).reduce((total, items) => total + items.length, 0),
    categories: Object.fromEntries(
      Object.entries(categorizedItems).map(([category, items]) => [category, items.length])
    ),
    updated_at: new Date().toISOString()
  }, { spaces: 2 });
  
  console.log(`‚úÖ Fichier global g√©n√©r√©: ${globalFile}`);
}

/**
 * Formate une dur√©e en millisecondes en format lisible
 * @param {number} ms - Dur√©e en millisecondes
 * @returns {string} - Dur√©e format√©e
 */
function formatDuration(ms) {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  
  if (hours > 0) {
    return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
}

// Ex√©cuter la fonction principale
main()
  .then(() => process.exit(0))
  .catch(error => {
    console.error('Erreur fatale:', error);
    process.exit(1);
  });
