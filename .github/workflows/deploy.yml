name: CI/CD FloDrama

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# Permissions n√©cessaires pour GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write

env:
  S3_BUCKET: flodrama-assets
  AWS_REGION: eu-west-3

jobs:
  backend:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4
      
      - name: Configuration de Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'
      
      - name: Configuration de Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: Backend/package-lock.json
      
      - name: Installation des d√©pendances Python
        run: |
          python -m pip install --upgrade pip
          if [ -f Backend/requirements.txt ]; then
            pip install -r Backend/requirements.txt
          else
            pip install aiohttp beautifulsoup4 boto3 fastapi pymongo redis opensearch-py pydantic
          fi
      
      - name: Installation des d√©pendances Node.js
        working-directory: ./Backend
        run: |
          if [ -f package.json ]; then
            npm ci
          else
            echo "Aucun package.json trouv√© dans le dossier Backend, cr√©ation d'un fichier minimal"
            echo '{
              "name": "flodrama-backend",
              "version": "1.0.0",
              "private": true,
              "scripts": {
                "start": "node src/lambda/index.js"
              },
              "dependencies": {
                "aws-sdk": "^2.1500.0"
              }
            }' > package.json
            npm install
          fi
      
      - name: Configuration AWS
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          role-duration-seconds: 3600
          role-session-name: GitHubActionsSession
      
      # Utiliser le secret s'il existe, sinon garder la valeur par d√©faut
      - name: Configuration de l'ID CloudFront
        run: |
          echo "üîë Configuration de l'ID CloudFront..."
          # Le secret sera utilis√© s'il existe, sinon la valeur par d√©faut sera conserv√©e
          if [ -n "$CLOUDFRONT_ID" ]; then
            echo "‚úÖ ID CloudFront r√©cup√©r√© depuis les secrets"
          else
            echo "‚ö†Ô∏è Utilisation de l'ID CloudFront par d√©faut"
          fi
        env:
          CLOUDFRONT_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
      
      - name: Ex√©cution du scraping et g√©n√©ration des donn√©es
        run: |
          echo "üîç Lancement du scraping et de la g√©n√©ration des donn√©es..."
          
          # Ex√©cution du script Python de g√©n√©ration de donn√©es
          python scripts/generate_demo_data.py
          
          # V√©rification des fichiers g√©n√©r√©s
          ls -la export_data/
          
          echo "‚úÖ G√©n√©ration des donn√©es termin√©e avec succ√®s!"
      
      - name: V√©rification du contenu S3
        id: check-s3-content
        run: |
          echo " V√©rification du contenu dans le bucket S3..."
          
          # V√©rifier si le bucket existe avant de lister son contenu
          if aws s3api head-bucket --bucket "${{ env.S3_BUCKET }}" 2>/dev/null; then
            # V√©rifier si le bucket contient des donn√©es
            CONTENT_COUNT=$(aws s3 ls s3://${{ env.S3_BUCKET }} --recursive | wc -l)
            
            if [ $CONTENT_COUNT -gt 0 ]; then
              echo " Contenu trouv√© dans le bucket S3: $CONTENT_COUNT fichiers"
              echo "HAS_CONTENT=true" >> $GITHUB_OUTPUT
            else
              echo " Aucun contenu trouv√© dans le bucket S3"
              echo "HAS_CONTENT=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è Le bucket ${{ env.S3_BUCKET }} n'existe pas ou n'est pas accessible"
            echo "HAS_CONTENT=false" >> $GITHUB_OUTPUT
            # Ne pas √©chouer le build si le bucket n'existe pas
            exit 0
          fi
      
      - name: Upload vers S3
        if: steps.check-s3-content.outputs.HAS_CONTENT == 'true'
        run: |
          echo "üì§ Upload des donn√©es vers S3..."
          
          # Upload des donn√©es vers S3
          aws s3 sync export_data/ s3://${{ env.S3_BUCKET }}/data/ --cache-control "max-age=3600"
          echo "‚úÖ Upload vers S3 termin√© avec succ√®s!"
      
      # √âtape d'invalidation du cache CloudFront avec gestion d'erreur
      - name: Invalidation du cache CloudFront
        if: steps.check-s3-content.outputs.HAS_CONTENT == 'true'
        run: |
          echo "üîÑ Tentative d'invalidation du cache CloudFront..."
          
          # V√©rifier si l'ID CloudFront est configur√©
          if [ -n "$CLOUDFRONT_ID" ]; then
            # Cr√©er une invalidation pour le chemin /data/*
            INVALIDATION_ID=$(aws cloudfront create-invalidation --distribution-id $CLOUDFRONT_ID --paths "/data/*" --query "Invalidation.Id" --output text)
            
            if [ -n "$INVALIDATION_ID" ]; then
              echo "‚úÖ Invalidation CloudFront cr√©√©e avec succ√®s (ID: $INVALIDATION_ID)"
            else
              echo "‚ö†Ô∏è √âchec de la cr√©ation de l'invalidation CloudFront"
            fi
          else
            echo "‚ö†Ô∏è Aucun ID CloudFront configur√©, invalidation ignor√©e"
          fi
        env:
          CLOUDFRONT_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
      
      - name: G√©n√©ration des fichiers de contenu agr√©g√©
        if: steps.check-s3-content.outputs.HAS_CONTENT == 'true'
        run: |
          echo "üîÑ G√©n√©ration des fichiers de contenu agr√©g√© pour le frontend..."
          
          # Ex√©cution du script Python d'agr√©gation
          python scripts/aggregate_content.py
          
          # Upload du fichier agr√©g√© vers S3
          aws s3 cp export_data/all_content.json s3://${{ env.S3_BUCKET }}/data/all_content.json --cache-control "max-age=3600"
          
          echo "‚úÖ G√©n√©ration des fichiers de contenu agr√©g√© termin√©e avec succ√®s!"
          
          # V√©rification du contenu du bucket
          echo "üìã Liste des fichiers dans le bucket S3:"
          aws s3 ls s3://${{ env.S3_BUCKET }} --recursive | grep -E 'featured|popular|recently|topRated|categories|metadata'
      
      # V√©rification de l'existence de la fonction Lambda
      - name: V√©rification de la fonction Lambda
        id: check-lambda
        run: |
          echo "üîç V√©rification de l'existence de la fonction Lambda..."
          
          # V√©rifier si la fonction Lambda existe d√©j√†
          if aws lambda get-function --function-name FloDramaImageOptimizer 2>/dev/null; then
            echo "‚úÖ La fonction Lambda FloDramaImageOptimizer existe d√©j√†"
            echo "LAMBDA_EXISTS=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è La fonction Lambda FloDramaImageOptimizer n'existe pas"
            echo "LAMBDA_EXISTS=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Cr√©ation de la fonction Lambda
        if: steps.check-lambda.outputs.LAMBDA_EXISTS == 'false'
        run: |
          echo "üîß Cr√©ation de la fonction Lambda..."
          
          # Cr√©ation du r√©pertoire pour la fonction Lambda
          mkdir -p lambda_function
          
          # Copie des fichiers de la fonction Lambda depuis les scripts
          cp scripts/lambda_image_optimizer.js lambda_function/index.js
          cp scripts/lambda_package.json lambda_function/package.json
          
          # Installation des d√©pendances
          cd lambda_function
          npm install --production
          
          # Cr√©ation du package ZIP
          zip -r ../lambda_function.zip .
          cd ..
          
          # Copie du fichier de politique de confiance depuis les scripts
          cp scripts/trust_policy.json .
          
          # Cr√©ation du r√¥le IAM pour la fonction Lambda
          ROLE_ARN=$(aws iam get-role --role-name LambdaS3Role 2>/dev/null | jq -r '.Role.Arn' || echo "")
          
          if [ -z "$ROLE_ARN" ]; then
            echo "Cr√©ation du r√¥le IAM pour la fonction Lambda..."
            
            # Cr√©ation du r√¥le
            ROLE_ARN=$(aws iam create-role --role-name LambdaS3Role --assume-role-policy-document file://trust-policy.json --query "Role.Arn" --output text)
            
            # Attachement des politiques n√©cessaires
            aws iam attach-role-policy --role-name LambdaS3Role --policy-arn arn:aws:iam::aws:policy/AmazonS3FullAccess
            aws iam attach-role-policy --role-name LambdaS3Role --policy-arn arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
            
            # Attente pour la propagation du r√¥le
            echo "‚è≥ Attente de 10 secondes pour la propagation du r√¥le IAM..."
            sleep 10
          else
            echo "‚úÖ R√¥le IAM existant: $ROLE_ARN"
          fi
          
          # Cr√©ation de la fonction Lambda
          aws lambda create-function \
            --function-name FloDramaImageOptimizer \
            --zip-file fileb://lambda_function.zip \
            --handler index.handler \
            --runtime nodejs18.x \
            --role $ROLE_ARN \
            --timeout 30 \
            --memory-size 1024
          
          echo "‚úÖ Fonction Lambda cr√©√©e avec succ√®s"
      
      - name: Mise √† jour de la fonction Lambda
        if: steps.check-lambda.outputs.LAMBDA_EXISTS == 'true'
        run: |
          echo "üîÑ Mise √† jour de la fonction Lambda..."
          
          # Cr√©ation du r√©pertoire pour la fonction Lambda
          mkdir -p lambda_function
          
          # Copie des fichiers de la fonction Lambda depuis les scripts
          cp scripts/lambda_image_optimizer.js lambda_function/index.js
          cp scripts/lambda_package.json lambda_function/package.json
          
          # Installation des d√©pendances
          cd lambda_function
          npm install --production
          
          # Cr√©ation du package ZIP
          zip -r ../lambda_function.zip .
          cd ..
          
          # Mise √† jour de la fonction Lambda
          aws lambda update-function-code \
            --function-name FloDramaImageOptimizer \
            --zip-file fileb://lambda_function.zip
          
          echo "‚úÖ Fonction Lambda mise √† jour avec succ√®s"
      
      # Nettoyage des anciennes versions Lambda
      - name: Nettoyage des anciennes versions Lambda
        if: steps.check-lambda.outputs.LAMBDA_EXISTS == 'true'
        run: |
          echo "üßπ Nettoyage des anciennes versions Lambda..."
          
          # Liste des versions sauf $LATEST et les 3 plus r√©centes
          VERSIONS_TO_DELETE=$(aws lambda list-versions-by-function --function-name FloDramaImageOptimizer --query "Versions[?Version!='$LATEST'].Version" --output text | tr '\t' '\n' | sort -n | head -n -3)
          
          # Suppression des anciennes versions
          for VERSION in $VERSIONS_TO_DELETE; do
            echo "Suppression de la version $VERSION..."
            aws lambda delete-function --function-name FloDramaImageOptimizer:$VERSION || true
          done
          
          # Configuration de la r√©tention des logs CloudWatch
          echo "‚è±Ô∏è Configuration de la r√©tention des logs CloudWatch..."
          aws logs put-retention-policy --log-group-name /aws/lambda/FloDramaImageOptimizer --retention-in-days 30
          
          echo "‚úÖ Nettoyage des anciennes versions Lambda termin√©"
      
  frontend:
    runs-on: ubuntu-latest
    needs: backend
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4
      
      - name: Configuration de Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: Frontend/package-lock.json
      
      - name: Construction du frontend
        working-directory: ./Frontend
        run: |
          echo "üì¶ Installation des d√©pendances..."
          npm install --legacy-peer-deps
          echo "üîë Configuration des variables d'environnement..."
          cp .env.production .env
          echo "üöÄ Construction de l'application React..."
          npm run build
          if [ $? -eq 0 ]; then
            echo "‚úÖ Construction du frontend r√©ussie!"
          else
            echo "‚ùå √âchec de la construction du frontend, cr√©ation d'une page d'attente temporaire..."
          fi

      - name: V√©rification du build frontend
        id: check-frontend
        run: |
          if [ -f Frontend/dist/index.html ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Build React trouv√© dans Frontend/dist/index.html"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "‚ùå Build React manquant dans Frontend/dist/index.html"
          fi

      - name: Cr√©er une page d'attente si le frontend n'existe pas
        if: ${{ steps.check-frontend.outputs.exists != 'true' }}
        run: |
          mkdir -p Frontend/dist
          if [ -f "Frontend/public/waiting-page.html" ]; then
            cp Frontend/public/waiting-page.html Frontend/dist/index.html
            echo "‚úÖ Page d'attente copi√©e avec succ√®s dans Frontend/dist/index.html"
          else
            echo "<html><head><title>FloDrama - Site en maintenance</title></head><body style='background:#121118;color:white;font-family:sans-serif;text-align:center;padding-top:50px;'><h1 style='color:#3b82f6;'>FloDrama</h1><p>Site en cours de d√©ploiement - Merci de votre patience</p></body></html>" > Frontend/dist/index.html
            echo "‚ö†Ô∏è Page d'attente simplifi√©e cr√©√©e dans Frontend/dist/index.html"
          fi

      - name: Installation de Surge
        run: npm install -g surge

      - name: D√©ploiement sur flodrama.com
        run: |
          echo "üöÄ D√©ploiement sur flodrama.com..."
          cd Frontend/dist
          surge --project ./ --domain flodrama.com --token ${{ secrets.SURGE_TOKEN }}
        env:
          SURGE_TOKEN: ${{ secrets.SURGE_TOKEN }}

      - name: Notification frontend
        run: echo "‚úÖ Frontend d√©ploy√© avec succ√®s sur https://flodrama.com"
